PRAGMA foreign_keys=OFF;
BEGIN TRANSACTION;
CREATE TABLE blog (
  id CHAR(40) NOT NULL,
  created datetime,
  title varchar(30) NOT NULL UNIQUE,
  content text,
  published tinyint(1) NOT NULL default '0',
  PRIMARY KEY  (id)
);
INSERT INTO "blog" VALUES('b8941efa9cff5165149cf23dc43ad6a6b205c8c7','2010-04-06 16:18:14','Object Relational Model','<p>As part of my ongoing work on a helpful Object Relational Model for PHP, for use in rapid prototyping and speedy development, I&#039;ve begun a blog application to test it out on.</p>
',1);
INSERT INTO "blog" VALUES('200c8930bfd9c62ee8fde511104749c21abc95da','2010-04-07 17:36:08','SQL Incompatibilities','<p>Having tried to switch over to SQLite I&#039;ve realised that my table aliases are incompatible; they are generated to be of the form &quot;0__0__tablename&quot; and apparently SQLite doesn&#039;t support aliases beginning with an integer. Meh.</p>
<p>So, that&#039;ll be another <a href = "http://github.com/ahri/orm/issues">issue</a> for my ORM to deal with.</p>
<p>I&#039;ve also added <a href = "http://daringfireball.net/projects/markdown/">Markdown</a> to my Blog frontend via <a href = "http://michelf.com/projects/php-markdown/">Michel Fortin&#039;s PHP port</a>, although I&#039;ve begun to consider writing a &quot;<a href = "lib/Node.classes.php">Node</a>&quot;-based version of <a href = "http://docutils.sourceforge.net/rst.html">reStructuredText</a> for PHP driven output, so if I ever get bored and wish to write another text markup parser, that&#039;s what I&#039;ll be working on!</p>
',1);
INSERT INTO "blog" VALUES('4c11332ca98cc16ea2fb9cce3126c114366db353','2010-05-04 11:46:43','HTML All the Way','<p>Having messed with Markdown a little I&#039;ve decided that it&#039;s really not worth the extra language requirement. The text output from this blog is always going to be in HTML so I may as well just write in HTML.</p>
<p>Of course there are some issues with allowing people to post comments in full HTML (when comments are supported) because they can muck around with the flow of the page. I tried alleviating this using <a href = "http://php.net/strip_tags">strip_tags()</a> but this really didn&#039;t help all that much because if I want to exclude inline javascript (e.g. for use in an onclick XSS attack) I&#039;d have to strip all link tags. I wanted higher control over the stripping process so I wrote my own that uses the DOM parser and my own Node classes.</p>
',1);
INSERT INTO "blog" VALUES('3a30e28c96041d23f9d4c3b67409feae52db60b1','2010-05-09 22:38:09','Android','<p>I&#039;m pretty happy with how the site backend is coming along and will now be shifting my focus to <a href = "http://android.com">Android</a> development, which was my prime interest in fixing up the site.</p>
<p>Of course, I&#039;ll continue fiddling with the style of the site as I see things that niggle!</p>
',1);
INSERT INTO "blog" VALUES('1099bccdb623e29c33c2153ab5528c41d006d347','2010-06-01 16:26:02','Actions!','<p>I messed around a little more with my CMS, adding a simple action director and modding apache&#039;s config so that the director is called when files are not found, for interpretation and resolution. This means that all 404s (unless specifically excluded by the apache config) are handled through the templating engine. Another reason for doing this was to have an overall try/catch construct to pleasantly display any exceptions that trickle down.</p>
<p>In the background I&#039;m now using <a href = "http://ckeditor.com">CKEditor</a> to make editing posts a bit more pleasant, though of course all of its output is being filtered by my custom routines for security. This should eventually make its way through to comment adding, which I expect I&#039;ll implement with <a href = "http://oauth.net">OAuth</a> in a similar manner to <a href = "http://stackoverflow.com">Stack Overflow</a> have done.</p>
<p>No news yet on the Android front, but the ideas are pilling up!</p>
',1);
INSERT INTO "blog" VALUES('324f27a2f0da906a9d5025e8a03b4aec5967ee31','2010-06-05 15:47:16','A Debate about C++ (Part 1)','<h2>Introdution</h2>
<p>At work I had a bit of a discussion with a colleague about C++ where I expressed an opinion that it is a language made up of too many design ideas that, while powerful, ends up being confusing and hard to maintain. Our discussion moved to email and it is from those original emails that I will create a series of posts, appropriately anonimised, illustrating the discussion.</p>
<p>The first part is from me, being quite antagonistic.</p>
<h2>Me:</h2>
<p>As promised; <a href = "http://www.relisoft.com/tools/CppCritic.html">this</a> captures most of my concerns around the C++ language. More amusing/inflammatory is Linus Torvalds&#039; <a href = "http://thread.gmane.org/gmane.comp.version-control.git/57643/focus=57918">opinion</a>.</p>
<p>Personally I don&#039;t have a problem with C++, I&#039;ve used it a little and poked around a bit. I think what bothers me most about it is the way it was built; on top of C. Then add STL. Then add Boost. Now you have lots of ways of doing the same thing, which as far as I can see is only useful to inflate the user&#039;s ego when something finally works.</p>
<p>I don&#039;t dispute that it&#039;s fast or that it can pretty much anything that any other language can do (even closures, <a href = "http://www.sleberknight.com/blog/sleberkn/entry/can_java_be_saved">nudge nudge</a>), but there is a lot about the design, or lack thereof, of the language that feels uncomfortable.</p>
<p>Disclaimer: I know that Boost isn&#039;t a core element of the <i>language</i>, it is however a core element of many C++ projects.</p>
',1);
INSERT INTO "blog" VALUES('4d09168e992b455fd306682ca7b7a7d6825de3df','2010-06-06 01:37:37','A Debate about C++ (Part 2)','<h2>Colleague:</h2>
<p>That article has one single problem with C++; that it&#039;s hard to parse so making tools for it are difficult (while openly admitting they haven&#039;t tried using the Eclipse IDE for C++)!</p>
<p>Basically saying that the developers aren&#039;t competent enough to do it by themselves, I know it&#039;s a pain because you have to &quot;know&quot; a lot more than with other languages that basically do everything for you but that&#039;s what causes so many software errors: developers using tools they don&#039;t fully understand. Where Java will probably let you get away with some errors and give you misleading results C++ will kick you square in the nuts and go tell you to read the user manual properly.</p>
<p>I never said it was easy but C++ is efficient, powerful, logical, safe (if used correctly), gives you direct access to the machine and the OS and overall you explicitly control everything the language is doing, no endless searching for memory leaks because the garbage collection is being a little too relaxed or performance issues because of an overzealous GC.</p>
<p>I was shocked and am a little dubious about Mr Linux&#039;s supposed article but <a href = "http://warp.povusers.org/OpenLetters/ResponseToTorvalds.html">this response</a> adequately counters in a far more succinct, less &quot;mad rant&quot; manner.</p>
',1);
INSERT INTO "blog" VALUES('9e6f3c748a6c6f34abaaf5b6173dadf08d541661','2010-06-06 01:49:08','A Debate about C++ (Part 3)','<h2>Me:</h2>
<p>I&#039;ll address the main points:</p>
<p>Safety; you say that C++ is &quot;safer&quot; because it&#039;ll &quot;kick you&quot; rather than giving misleading results. As far as I know there is no &quot;safe&quot; version of C++, whereas C has versions such as <a href = "http://en.wikipedia.org/wiki/Cyclone_%28programming_language%29">Cyclone</a> and <a href = "http://en.wikipedia.org/wiki/MISRA_C">MISRA-C</a> which is used in safety-critical systems in a similar vein to <a href = "http://en.wikipedia.org/wiki/Ada_%28programming_language%29">Ada</a> and C++ isn&#039;t used in weapon systems. Back to normal systems though, I don&#039;t think even then you can consider C++ to be anywhere near &quot;safe&quot;: what about memory leaks? It&#039;s easy to create memory leaks in both C and C++, and pretty hard to detect them with seemingly random crashes. Yes, with experience you can avoid these problems, but most people don&#039;t have the necessary experience. Which brings me to my next point:</p>
<p>Ego; your assertions that developers are (or should be) competent enough to use the tools, and basically don&#039;t need babysitting. What about late nights? What about office distractions? It&#039;s hard to stay focused enough to avoid the abundance of pitfalls that you get in languages like C++/C when compared with &quot;safer&quot; or higher level languages I&#039;m advocating. Most crucially though, what about code maintenance? You might be able to tell me that you&#039;re completely infallible (and I reserve the right to disagree!) but you can&#039;t tell me that the next guy maintaining your code will be. This can be extended to a normal development team; it&#039;s so easy to take someone else&#039;s code, misunderstand something in there (especially in C++ where there are so many idioms for the same damn thing) and introduce tricky bugs. So any chest beating about C++&#039;s amazing power when used by an amazing programmer such as yourself is just ego over pragmatism.</p>
<p>As for access to the system; uhm, how many OS are written in C++? Popular ones? Thought so. Drivers? C wins again. With C you have something cleaner, smaller and with the same access. Granted, it&#039;s pretty messy to try doing OO in C, but given that C predates widespread OO usage and was never meant for OO this doesn&#039;t seem to me an omission.</p>
<p>The only real situation where you need that level of access to the system that C++ can give you, ignoring embedded systems (which, let&#039;s face it, are more likely to use C anyway), is in writing games. To be fair to you, this is a winning argument for your side: iD&#039;s Tech 4 engine made the switch from C (which all the Doom/Quake games used) over to C++ after they&#039;d written the renderer, I believe this is because John Carmack decided that C++ compilers had finally caught up with C in their optimization routines; this is unsubstantiated though.</p>
<p>Now for the addendums (addendi?) don&#039;t be dubious; Linus has a long history of that kind of rant. I don&#039;t necessarily think he&#039;s right, but I&#039;m a lot more inclined to believe someone maintaining an OS kernel of a few million lines of C than someone whose first decision in a reply is to construct a straw man argument...</p>
',1);
INSERT INTO "blog" VALUES('bed17ab121e41d13038514fdd05e9be3e7be56f4','2010-06-06 01:56:33','A Debate about C++ (Part 4)','<h2>Colleague:</h2>
<p>Your responses confuse me!</p>
<p>On one hand you play the card that C++ is too hard to develop in and maintain and then go straight on to promote the glory of C and basically talk about the benefits of non-OO languages???</p>
<p>C is an absolute nightmare to develop and maintain because it lacks all the benefits to OO coding which is precisely there to provide code reuse, maintainability, scalability and encapsulation. I&#039;ve had to write device drivers using C and it takes a million lines of code to do anything and is very unreadable and difficult to maintain because of the sheer amount of code needed to read through to get to the point.</p>
<p>Heralding C as the better language because it&#039;s faster and has a smaller footprint is obvious, because is it&#039;s like half of C++! If you really want you can start writing operating systems in machine code which you can optimise to every single instruction.... if YOU want to then go right ahead. The reason it&#039;s used in operating systems is mainly historic because the kernels already existed before OO concepts really hit the ground, some parts of windows are allegedly developed in C++ (ask Microsoft and I&#039;m sure they&#039;ll be willing to share). At the end of the day it&#039;s all getting compiled to machine code so the difference between C and C++ lies simply in the ease of development and the ability of the optimizer.</p>
<p>As for C++ being unsafe and having memory leaks, these are again at the hands of the developer not automated processes like GC and it&#039;s standard practice to provide destructors and call them when an object is being dereferenced. It&#039;s not egotistical to believe a developer should fully understand and test his code before it goes live, it&#039;s the very least you can ask of an I.T. professional. I&#039;m not infallible but you better hope the system of unit test, system tests, integration tests, capacity volume tests, performance tests and finally user acceptance tests is adequate to catch errors otherwise there is something very wrong with the process.</p>
<p>As for safety critical systems, I believe many projects have been created using C++. I know of one for the Navy that an old lecturer used to work on, which had to use a separate compiler because the Borland one (I think) used one machine instruction that was not in the instruction set deemed acceptable for the solution. Also some very complex systems around are nations intelligence is written in C++ as another lecturer of mine developed something in that area for GCHQ and it was then later employed in some remote voting system. Real time systems are usually developed at a much lower level so the obvious choice is a procedural non-OO language but surely you&#039;re not contesting that OO was the way forward for development?</p>
<p>I think we&#039;re straying away from the argument here, I was defending C++ against its contemporaries and promoting its benefits over its predecessor. I&#039;m not saying every solution should be written in C++ because some time speed of development is actually more important that a fast reliable system. I like writing in PHP, it&#039;s great simple and easy. Would I develop anything worthwhile in it, probably not.</p>
',1);
INSERT INTO "blog" VALUES('943eac19f7b574b617850c8e4327a7d999865280','2010-06-06 08:55:37','A Debate about C++ (Part 5)','<h2>Me:</h2>
<p>I&#039;m not talking about the benefits of non-OO languages; if anything I&#039;m saying that of the OO languages C++ is too complex for its own good and has a minority of appropriate use-cases. There are lots of great OO languages around that don&#039;t have these problems. Most programs don&#039;t need the speed that C++ can give you, and for OO elegance I personally think there are better options.</p>
<p>I think you have become confused; I&#039;m not heralding any language as the best; I&#039;m saying that where power is needed I&#039;d probably choose C, and where OO is needed I&#039;d choose whatever language seems most appropriate to the job: Java, C#, perhaps Ruby or Python. If I was writing a game I might well choose C++, indeed, I have already made that choice for a Nintendo DS game I don&#039;t have any time to write ;-)</p>
<p>There&#039;s no point in you trying to win an argument around C++ where Operating Systems are concerned. It&#039;s unwinnable. In fact a quick check gives me a glorious fact; Microsoft&#039;s rather interesting <a href = "http://en.wikipedia.org/wiki/Singularity_%28operating_system%29">Singularity</a> OS has its interrupt code written in C and Assembly, and then skips way up the chain to a C# derived language for the rest of the OS. They used the right tools for the right jobs; C/Assembly for the thin core and managed code for the rest. So existing OSs (Windows, Linux, BSD -- and therefore MacOSX) use C, and a cutting edge OS uses a combination of C and managed code.</p>
<p>I don&#039;t really understand your perspective on C++ and memory leaks; you seem to think it&#039;s a good think that I should have to pay attention to trivialities that have been solved in other languages. I also complain that maintaining C++ code (unless it has severe code guidelines applied) can be more of a pain that other comparable (OO) languages. You&#039;re not being egotistical for believing a developer should understand the tools available to him; you&#039;re being naive: they don&#039;t. You&#039;re only being egotistical when you sound like you think you won&#039;t make the mistakes that C++ very kindly makes easy for you.</p>
<p>The point about memory leaks isn&#039;t that they are avoidable, it&#039;s that they&#039;re easy to create in the first place. Relying on time consuming processes to mitigate risks that can be avoided using a different language seems like a waste to me. Don&#039;t latch onto this as an indication that I&#039;m now crusading against process; I just think that process can be used to find other problems that we haven&#039;t already solved in other languages. No point wasting resources on C++ unless it&#039;s delivering a crucial benefit -- like in required speed.</p>
<p>I&#039;ll let the point about safety critical or realtime systems slide; I don&#039;t think there are anywhere near as many such systems written in C++ as there are in C, but I have sufficiently little interest in that area having had to learn Ada that I&#039;m not going to bother researching it further :-P I never once contested the use of OO -- just C++ -- I think you&#039;re becoming deluded in your confusion; there is a difference between OO and C++, you know ;-)</p>
<p>I don&#039;t think I&#039;ve strayed; C++ has its place: mostly in making stuff like games run faster, though I believe even there there is a trend to develop minimal engines in such performant languages and drop to Lua or the like for logic and content. In most cases I think that Java or C# will get you what you need with less code and more safety -- basically my view is the inverse of yours: most of the time we don&#039;t need performance, we need to get a working application out there (that we can maintain easily in a conventional process); in the very few cases where we do need performance and OO in one place, I think you&#039;re right: we need C++.</p>
<p>I don&#039;t know what insight your parting comment about PHP is supposed to impart; Facebook&#039;s shareholders seem to think it&#039;s &quot;worthwhile&quot;, after all. Here, again, I hear ego rather than sense.</p>
',1);
INSERT INTO "blog" VALUES('3e4f4f8e0a983b823870c9f5acb3361afaa1451b','2010-06-06 08:56:03','A Debate about C++ (Part 6)','<h2>Colleague:</h2>
<p>Not having time to respond myself, here are <a href = "http://www.cantrip.org/realworld.html">some musings</a> of an obvious software &quot;engineer&quot; who respects the potential of C++ and quite succinctly explains why there will always be a need for it and why it&#039;s often a far better to choose if your tool belt only fits one language.</p>
<h2>Wrap-up</h2>
<p>This ended the debate as we both had too much work to do to continue, and had already made our points without too much repitition. I&#039;m not going to provide a summary or a conclusion as I can&#039;t do so without introducing my bias, so you&#039;ll have to make your own mind up whose points chime most with your perspective on the issue.</p>
',1);
INSERT INTO "blog" VALUES('6e9a1c4a48c1c92965bb9c3136fb7dc6cad292c7','2010-07-23 20:13:04','EuroPython 2010','<p>For the last week I&#039;ve been enjoying <a href = "http://www.europython.eu">EuroPython</a> 2010, learning a whole lot of new stuff and having my mind exercised thoroughly with a whole load of things I mostly didn&#039;t understand. Still, it was a really good experience and the people were so friendly that I think it would be nearly impossible not to have a good time over there!</p>
<p>I&#039;ve begun experimenting a bit more with Python and decided to write a <a href = "http://en.wikipedia.org/wiki/Bomberman">Bomberman</a><a href = "http://github.com/ahri/bomber"> clone</a> in order to test out some <a href = "http://en.wikipedia.org/wiki/Test-driven_development">TDD</a> and hopefully soon some event based coding using <a href = "http://github.com/saucelabs/monocle">Monocle</a> and eventually some network based stuff. As I state in the <a href = "http://github.com/ahri/bomber/blob/master/README">README</a> I want it to be quite flexible as far as portability and client type (console/gui) are concerned.</p>
<p>I&#039;ve never really done much event based stuff so I&#039;m hoping that Monocle is gentle ;) What really inspired me to try this way <a href = "http://twitter.com/raymondh">Raymond Hettinger</a>&#039;s wonderful talk on it, following his equally fantastic talk on Idiomatic Python. It&#039;s really great that the Python community has such eloquent and entertaining speakers to inspire me like this!</p>
',1);
INSERT INTO "blog" VALUES('1a6e66cae94bce803f47ba842c0eb02d48e86f3c','2010-08-09 08:31:03','Bomberman','<p>As an aid to learning Python I&#039;ve begun writing a Bomberman clone for which I have an <a href = "http://github.com/ahri/bomber">alpha state</a> engine ready for download and prying eyes :-)</p>
<p>The long-term plan is to get it running as an event-based server which can then accept clients from anywhere, including a GUI written in Python that will be cross platform and based upon <a href = "http://www.pygame.org/news.html">pygame</a>, a console version for POSIX systems with ncurses, also written in Python, and finally, maybe, an Android client for mobile play. What I want is to allow multiple client types all playing on the same server.</p>
<p>Obviously some of this is quite ambitious for someone who is really still learning, and the goals are fairly up in the air as far as assurance of completion goes. What I do know is that I want to get something ready to play with very soon in order to keep the other half (Jenn) interested in what I&#039;m doing.</p>
<p>Right now I&#039;m reading up on <a href = "http://eventdrivenpgm.sourceforge.net/">Event Driven Programming</a> in the hopes of learning from the mistakes of others, and to get a stronger grip on the problem at hand. More to come!</p>
',1);
INSERT INTO "blog" VALUES('8bc74a0ff788e8edf20881f86bcb904b7ea54aa4','2010-08-10 14:04:47','Bottom Up vs Top Down','<p>Summary</p>
<p>TDD</p>
<p>Prototyping</p>
<p>Design Experience</p>
',0);
COMMIT;
